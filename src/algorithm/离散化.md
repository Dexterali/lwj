# 离散化

假设 \\(a[x], x \in n\\) 其中 \\(n\\) 的范围较大但 \\(a[]\\)  元素较少且可能有重复，去重之后只有 \\(m\\) 个数。 将 \\(a[x]\\) 用 \\(1 \sim m\\) 之间的整数代替，且大小顺序不变，即是离散化。

## 思路
将 \\(a\\) 数组**排序去重**得到数组 \\(b[1 \sim m]\\)

如要查询整数 \\(i\\) 代替的数值，则返回 \\(b[i]\\)

如要查询 \\(a[i]\\) 被 \\(1 \sim m\\) 之间的哪个整数代替，则返回数组 \\(b\\) 中 **二分查找** \\(a[i]\\) 的位置

```cpp
// a 表示离散化前，b 表示离散化得到的结果
int a[n], b[m];

// 离散化
void discrate() {
    // 排序
    sort(a, a + n);
    // 去重
    int cnt = 0;
    for (int i = 0; i < n; i++) {
        if (i == 0 || a[i] !+ a[i -1]) {
            b[cnt++] = a[i];
        }
    }
}

// 二分查询 x 映射为哪个 1 ~ m 之间的整数
int query(int x) {
    int l = 0, r = n - 1;
    while (l < r) {
        int mid = (l + r) >> 1;
        if (b[mid] >= x) {
            r = mid;
        } else {
            l = mid + 1;
        }
    }

    return l;
}
```