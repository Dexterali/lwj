# 地址空间

## Rust智能指针/容器及其他类型的内存布局

<img title="" src="http://rcore-os.cn/rCore-Tutorial-Book-v3/_images/rust-containers.png" alt="">



## 1. risc-v SV39多级页表的硬件机制

> 默认情况下 MMU 未被使能（启用），此时无论 CPU 位于哪个特权级，访存的地址都会作为一个物理地址交给对应的内存控制单元来直接访问物理内存。我们可以通过修改 S 特权级的一个名为 `satp` 的 CSR 来启用分页模式，在这之后 S 和 U 特权级的访存地址会被视为一个虚拟地址，它需要经过 MMU 的地址转换变为一个物理地址，再通过它来访问物理内存；而 M 特权级的访存地址，我们可设定是内存的物理地址。



<img title="" src="http://rcore-os.cn/rCore-Tutorial-Book-v3/_images/satp.png" alt="" data-align="center">

上图是 RISC-V 64 架构下 `satp` 的字段分布，含义如下：

- `MODE` 控制 CPU 使用哪种页表实现；

- `ASID` 表示地址空间标识符，这里还没有涉及到进程的概念，我们不需要管这个地方；

- `PPN` 存的是根页表所在的物理页号。这样，给定一个虚拟页号，CPU 就可以从三级页表的根页表开始一步步的将其映射到一个物理页号。



当 `MODE` 设置为 0 的时候，代表所有访存都被视为物理地址；而设置为 8 的时候，SV39 分页机制被启用，所有 S/U 特权级的访存被视为一个 39 
位的虚拟地址，它们需要先经过 MMU 的地址转换流程，如果顺利的话，则会变成一个 56 
位的物理地址来访问物理内存；否则则会触发异常，这体现了分页机制的内存保护能力。

39 位的虚拟地址可以用来访问理论上最大`512GiB`的地址空间，而 56 位的物理地址在理论上甚至可以访问一块大小比这个地址空间的还高出几个数量级的物理内存。但是实际上无论是虚拟地址还是物理地址，真正有意义、能够通过 MMU 的地址转换或是 CPU 内存控制单元的检查的地址仅占其中的很小一部分，因此它们的理论容量上限在目前都没有实际意义

<img title="" src="http://rcore-os.cn/rCore-Tutorial-Book-v3/_images/sv39-va-pa.png" alt="" data-align="center">

> **RISC-V 64 架构中虚拟地址为何只有 39 位？**
> 
> 在 64 位架构上虚拟地址长度确实应该和位宽一致为 64 位，但是在启用 SV39 分页模式下，只有低 39 位是真正有意义的。SV39 分页模式规定 64 位虚拟地址的`[63:39]`这 25 位必须和第 38 位相同，否则 MMU 会直接认定它是一个不合法的虚拟地址。通过这个检查之后 MMU 再取出低 39 位尝试将其转化为一个 56 位的物理地址。
> 
> 也就是说，所有 `2^64`个虚拟地址中，只有最低的`256GIB` （当第 38 位为 0 时）以及最高的 `256GIB`（当第 38 位为 1 时）是可能通过 MMU 检查的。当我们写软件代码的时候，一个地址的位宽毋庸置疑就是 64 
> 位，我们要清楚可用的只有最高和最低这两部分，尽管它们已经巨大的超乎想象了；而本节中我们专注于介绍 MMU 的机制，强调 MMU 看到的真正用来地址转换的虚拟地址只有 39 位。
